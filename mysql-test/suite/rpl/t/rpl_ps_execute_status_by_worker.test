#
# WL#3656- Table:performance_schema.replication_execute_status_by_worker
#
source include/master-slave.inc;
source include/have_binlog_format_mixed.inc;

call mtr.add_suppression("Error 'Table 'test.t' doesn't exist' on query.");
call mtr.add_suppression("The slave coordinator and worker threads are stopped, possibly leaving data in inconsistent state.");
call mtr.add_suppression("Request to stop slave SQL Thread received while applying a group that has non-transactional changes;");

--connection slave
source include/stop_slave.inc;
SET @save.slave_parallel_workers=@@global.slave_parallel_workers;
SET @@global.slave_parallel_workers=1;
source include/start_slave.inc;

--disable_result_log
# Verify that the select * works.
query_vertical select * from performance_schema.replication_execute_status_by_worker;

#Verify that insert, update and delete do not work.
error ER_TABLEACCESS_DENIED_ERROR;
insert into performance_schema.replication_execute_status_by_worker values(1);
error ER_TABLEACCESS_DENIED_ERROR;
update performance_schema.replication_execute_status_by_worker set Service_State='';
error ER_TABLEACCESS_DENIED_ERROR;
delete from performance_schema.replication_execute_status_by_worker;
--enable_result_log

let $ps_value= query_get_value(select Worker_Id from performance_schema.replication_execute_status_by_worker, Worker_Id, 1);
let $assert_text= Worker_Id should be 0;
let $assert_cond= "$ps_value"= 0;
source include/rpl_assert.inc;

# To verify that the worker thread_id is correctly shown by PS table, find the
# row in SHOW PROCESSLIST that corresponds to worker thread and extract the
# Id field shown in that row.
# This is implemented by dumping the SHOW PROCESSLIST output in a file
# and looking for the string "Waiting for an event from Coordinator" in a line
# in the dumped file. The Id field in the that line is then extracted to obtain
# the worker thread_id.

let $out_file=$MYSQLTEST_VARDIR/tmp/show_processlist_output.txt;
exec $MYSQL_SLAVE -e "show processlist" > $out_file;
let INPUT_FILE= $out_file;
let $ps_value= query_get_value(select Thread_Id from performance_schema.replication_execute_status_by_worker, Thread_Id, 1);
let WORKER_THREAD_ID= $ps_value ;

perl;
use strict;
my $input_file= $ENV{'INPUT_FILE'} or die "INPUT_FILE not set\n";
my $worker_thread_id= $ENV{'WORKER_THREAD_ID'} or die "SQL_THREAD_ID not set\n";
open(IN_FILE, "$input_file") or die("Unable to open '$input_file': $!\n");
while (<IN_FILE>)
{
  if (/(\d+)(.*?)(Waiting\s+for\s+an\s+event\s+from\s+Coordinator)(.*?)$/)
  {
    if ($worker_thread_id == $1)
    {
      print "worker thread id extracted from SHOW PROCESSLIST and PS table match.\n";
    }
    else
    {
      print "worker thread id extracted from SHOW PROCESSLIST and PS table do NOT match.\n";
    }
  }
}

close(IN_FILE);
EOF

remove_file $out_file;

let $ps_value= query_get_value(select Service_State from performance_schema.replication_execute_status_by_worker, Service_State, 1);
let $assert_text= Service_State should be "On" on a fresh slave server.;
let $assert_cond= "$ps_value"= "On";
source include/rpl_assert.inc;

let $ps_value= query_get_value(select Last_Seen_Transaction from performance_schema.replication_execute_status_by_worker, Last_Seen_Transaction, 1);
let $assert_text= Last_Seen_Transaction should show "ANONYMOUS" if gtid-mode=off.;
let $assert_cond= "$ps_value" = "ANONYMOUS";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_worker, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_execute_status_by_worker, Last_Error_Message, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Message should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_worker, Last_Error_Timestamp, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

# We now introduce an error in the worker thread and check for the correctness
# of error number, message and timestamp fields.

# Cause an error in Worker thread.
--connection master
use test;
create table t(a int primary key);
sync_slave_with_master;
drop table t;
--connection master
insert into t values(1);
--connection slave
let $slave_sql_errno=1146;
source include/wait_for_slave_sql_error.inc;


# Extract the error related fields from SSS and PS table and compare them
# for correctness.
let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_worker, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_execute_status_by_worker, Last_Error_Message, 1);

let PS_VALUE= $ps_value;
let SSS_VALUE= $sss_value;

perl;
use strict;
my $ps_value= $ENV{'PS_VALUE'};
my $sss_value= $ENV{'SSS_VALUE'};

if ($ps_value eq $sss_value)
{
  print "Value returned by SSS and PS table for Last_Error_Message is same.\n";
}
else
{
  print "Value returned by SSS and PS table for Last_Error_Message is NOT same\n";
}
EOF

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_worker, Last_Error_Timestamp, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

# Verify that the error fields are preserved after STOP SLAVE.

# Extract the error related fields from SSS and PS table and compare them
# for correctness.
let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_worker, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_execute_status_by_worker, Last_Error_Message, 1);

let PS_VALUE= $ps_value;
let SSS_VALUE= $sss_value;

perl;
use strict;
my $ps_value= $ENV{'PS_VALUE'};
my $sss_value= $ENV{'SSS_VALUE'};

if ($ps_value eq $sss_value)
{
  print "Value returned by SSS and PS table for Last_Error_Message is same.\n";
}
else
{
  print "Value returned by SSS and PS table for Last_Error_Message is NOT same\n";
}
EOF

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_worker, Last_Error_Timestamp, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

STOP SLAVE;
RESET SLAVE;
--connection master
drop table t;
RESET MASTER;

# Set up replication in gtid-mode=on and test Last_Seen_Transaction.
let $rpl_server_number= 1;
let $rpl_start_with_gtids= 1;
source include/rpl_restart_server.inc;

let $rpl_server_number= 2;
let $rpl_start_with_gtids= 1;
source include/rpl_restart_server.inc;

--connection slave
stop slave;
replace_result $MASTER_MYPORT MASTER_MYPORT;
replace_column 2 ####;
eval change master to master_host='127.0.0.1',master_port=$MASTER_MYPORT, master_user='root';
SET @save.slave_parallel_workers=@@global.slave_parallel_workers;
SET @@global.slave_parallel_workers=1;
start slave;

--connection master
create database d1;
create table d1.t1(a int);
insert into d1.t1 values(1);
let $MASTER_UUID= query_get_value(`SHOW VARIABLES LIKE '%server_uuid%'`, Value, 1);

sync_slave_with_master;

replace_result $MASTER_UUID MASTER_UUID;
query_vertical select Last_Seen_Transaction from performance_schema.replication_execute_status_by_worker;

source include/rpl_end.inc;
