#
# ==== Purpose ====
#
# WL#6559 Optimize GTIDs for passive slave - store GTIDs in table
#
# Verify that we can store gtids into gtid_executed table for transactions
# and report GLOBAL.GTID_EXECUTED and GLOBAL.GTID_PURGED correctly on
# master and slave when binlog is enabled.
#

--source include/master-slave.inc
--source include/have_gtid.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc

call mtr.add_suppression("test the suppression statement");
--let $master_uuid= `SELECT @@GLOBAL.SERVER_UUID`
SHOW CREATE TABLE mysql.gtid_executed;

--echo # Verify that the specified gtid to GTID_NEXT is stored into
--echo # gtid table and can be reported from global.gtid_executed.
--replace_result $master_uuid MASTER_UUID
--eval SET GTID_NEXT='$master_uuid:3'
BEGIN;
COMMIT;
--echo # Stored gtids MASTER_UUID:1:3 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1:3
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1:3"
--source include/assert.inc

--eval SET GTID_NEXT='AUTOMATIC'
--echo # Verify that these gtids are stored into gtid table and can be
--echo # reported from global.gtid_executed for normal DDLs.
CREATE TABLE IF NOT EXISTS t1 (a INT) ENGINE=InnoDB;
CREATE TABLE t2 (a INT) ENGINE=MyISAM;
--echo # Stored gtids MASTER_UUID:1-4 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-4
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-4"
--source include/assert.inc

--echo # Verify that these gtids are stored into gtid table and can be
--echo # reported from global.gtid_executed for compound statement with
--echo # regular and temporary tables.
CREATE TEMPORARY TABLE tmp1 (c1 INT) Engine=MyISAM;
CREATE TABLE t3 (a INT);
if (`SELECT @@BINLOG_FORMAT = 'ROW'`)
{
  # We did not generate gtid for above 'CREATE TEMPORARY TABLE' statement
  # in row format, but we did in statement format. So let the 'INSERT'
  # statement generate the missed gtid in row format.
  --disable_query_log
  INSERT INTO t3 VALUES(1);
  --enable_query_log
}
--error ER_BAD_TABLE_ERROR
DROP TEMPORARY TABLE tmp1, t3;
DROP TABLE t3;
--echo # Stored gtids MASTER_UUID:1-8 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-8
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-8"
--source include/assert.inc

--echo # Verify that transactions' gtids are stored into gtid table and can be
--echo # reported from global.gtid_executed correctly.
BEGIN;
INSERT INTO t2 VALUES(2);
INSERT INTO t1 VALUES(1);
INSERT INTO t1 VALUES(2);
COMMIT;
--echo # Verify that specified gtid is stored into gtid table for transaction
--echo # and can be reported from global.gtid_executed correctly.
--replace_result $master_uuid MASTER_UUID
--eval SET @@SESSION.GTID_NEXT= '$master_uuid:11'
BEGIN;
INSERT INTO t1 VALUES(3);
COMMIT;
--eval SET GTID_NEXT='AUTOMATIC'
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc

--echo # Verify that transaction's gtid is not stored into gtid table
--echo # if the transaction is rollbacked.
BEGIN;
INSERT INTO t1 VALUES(4);
ROLLBACK;
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc

--echo # Verify that transaction's gtid is not stored into gtid table
--echo # and the transaction is rolled back if we encounter an error
--echo # when writing gtid into table.
SET SESSION debug="+d,simulate_err_on_write_gtid_into_table";
--ERROR ER_GET_ERRNO
INSERT INTO t1 VALUES(5);
SET SESSION debug="-d,simulate_err_on_write_gtid_into_table";
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc
--let $assert_text= Table t1 must not contain 5
--let $assert_cond= "[SELECT a FROM t1 WHERE a=5]" = ""
--source include/assert.inc

--echo # Verify that transaction's gtid is not stored into gtid table
--echo # and the transaction is rolled back if we encounter an error
--echo # when generating automatic gtid.
SET SESSION debug="+d,simulate_gno_exhausted";
--ERROR ER_GNO_EXHAUSTED
INSERT INTO t1 VALUES(6);
SET SESSION debug="-d,simulate_gno_exhausted";
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc
--let $assert_text= Table t1 must not contain 6
--let $assert_cond= "[SELECT a FROM t1 WHERE a=6]" = ""
--source include/assert.inc

--source include/sync_slave_sql_with_master.inc
--echo connection slave
--let $slave_uuid= `SELECT @@GLOBAL.SERVER_UUID`

--echo # Verify that the transaction is skiped if its specified gtid
--echo # is already in gtid table.
--replace_result $master_uuid MASTER_UUID
--eval SET @@SESSION.GTID_NEXT= '$master_uuid:6'
INSERT INTO t1 VALUES(11);
--let $assert_text= Table t1 must not contain 11
--let $assert_cond= "[SELECT a FROM t1 WHERE a=11]" = ""
--source include/assert.inc
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on slave
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;

--echo # Verify that the specified gtid to GTID_NEXT is stored into
--echo # gtid table.
--replace_result $master_uuid MASTER_UUID
--eval SET @@SESSION.GTID_NEXT= '$master_uuid:17'
COMMIT;
--echo # Stored gtids MASTER_UUID:1-11:17 in gtid_executed table on slave
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11:17
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11:17"
--source include/assert.inc

--eval SET GTID_NEXT='AUTOMATIC'
FLUSH LOGS;
--let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
--echo # Verify that we can get the correct set of gtid_purged
--echo # when purging logs.
--eval PURGE BINARY LOGS TO '$binlog_file'
--let $assert_text= purged gtids MASTER_UUID:1-11:17
--let $assert_cond= "[SELECT @@GLOBAL.GTID_PURGED]" = "$master_uuid:1-11:17"
--source include/assert.inc

--echo # Verify that transaction's gtid generated on slave is stored
--echo # into gtid table.
BEGIN;
INSERT INTO t1 VALUES(12);
COMMIT;
--echo # Stored gtids MASTER_UUID:1-11:17 and SLAVE_UUID:1
--echo # in gtid_executed table on slave.
--replace_result $master_uuid MASTER_UUID
--eval SELECT * FROM mysql.gtid_executed where sid="$master_uuid"
--replace_result $slave_uuid SLAVE_UUID
--eval SELECT * FROM mysql.gtid_executed where sid="$slave_uuid"

--connection master
DROP TABLE t1, t2;

--source include/rpl_end.inc
