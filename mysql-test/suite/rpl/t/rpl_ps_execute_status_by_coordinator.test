#
# WL#3656- Table:performance_schema.replication_execute_status_by_coordinator
#
source include/master-slave.inc;
source include/have_binlog_format_mixed.inc;

call mtr.add_suppression("Error 'Table 'test.t' doesn't exist' on query.");

--connection slave

--disable_result_log
# Verify that the select * works.
query_vertical select * from performance_schema.replication_execute_status_by_coordinator;

#Verify that insert, update and delete do not work.
error ER_TABLEACCESS_DENIED_ERROR;
insert into performance_schema.replication_execute_status_by_coordinator values(1);
error ER_TABLEACCESS_DENIED_ERROR;
update performance_schema.replication_execute_status_by_coordinator set Service_State='';
error ER_TABLEACCESS_DENIED_ERROR;
delete from performance_schema.replication_execute_status_by_coordinator;
--enable_result_log

# To verify that the SQL thread_id is correctly shown by PS table, find the
# row in SHOW PROCESSLIST that corresponds to SQL thread and extract the
# Id field shown in that row.
# This is implemented by dumping the SHOW PROCESSLIST output in a file
# and looking for the string "Slave has read all relay log; waiting for the
# slave I/O thread to update" in a line # in the dumped file. The Id field
# in the that line is then extracted to obtain the SQL thread_id.
let $out_file=$MYSQLTEST_VARDIR/tmp/show_processlist_output.txt;
exec $MYSQL_SLAVE -e "show processlist" > $out_file;
let INPUT_FILE= $out_file;
let $ps_value= query_get_value(select Thread_Id from performance_schema.replication_execute_status_by_coordinator, Thread_Id, 1);
let SQL_THREAD_ID= $ps_value;

perl;
use strict;
my $input_file= $ENV{'INPUT_FILE'} or die "INPUT_FILE not set\n";
my $sql_thread_id= $ENV{'SQL_THREAD_ID'} or die "SQL_THREAD_ID not set\n";
open(IN_FILE, "$input_file") or die("Unable to open '$input_file': $!\n");
while (<IN_FILE>)
{
  if (/(\d+)(.*?)(Slave\s+has\s+read\s+all\s+relay\s+log)(.*?)$/)
  {
    if ($sql_thread_id == $1)
    {
      print "sql thread id extracted from SHOW PROCESSLIST and PS table match.\n";
    }
    else
    {
      print "sql thread id extracted from SHOW PROCESSLIST and PS table do NOT match.\n";
    }
  }
}

close(IN_FILE);
EOF

remove_file $out_file;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_coordinator, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_connection_status, Last_Error_Message, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Message should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_coordinator, Last_Error_Timestamp, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be 0000-00-00 00:00:00.;
let $assert_cond= "$ps_value" = "0000-00-00 00:00:00";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Slave_SQL_Running, 1);
let $ps_value= query_get_value(select Service_State from performance_schema.replication_execute_status_by_coordinator, Service_State, 1);
let $assert_text= SSS shows Slave_SQL_Running as "Yes". So, Service_State from this PS table should be "On".;
let $assert_cond= "$sss_value" = "Yes" AND "$ps_value"= "On";
source include/rpl_assert.inc;

# We now introduce an error in the SQL thread and check for the correctness
# of error number, message and timestamp fields.

# Cause an error in SQL thread.
--connection master
use test;
create table t(a int primary key);
sync_slave_with_master;
drop table t;
--connection master
insert into t values(1);
--connection slave
let $slave_sql_errno=1146;
source include/wait_for_slave_sql_error.inc;


# Extract the error related fields from SSS and PS table and compare them
# for correctness.
let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_coordinator, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_execute_status_by_coordinator, Last_Error_Message, 1);

let PS_VALUE= $ps_value;
let SSS_VALUE= $sss_value;

perl;
use strict;
my $ps_value= $ENV{'PS_VALUE'};
my $sss_value= $ENV{'SSS_VALUE'};

if ($ps_value eq $sss_value)
{
  print "Value returned by SSS and PS table for Last_Error_Message is same.\n";
}
else
{
  print "Value returned by SSS and PS table for Last_Error_Message is NOT same\n";
}
EOF

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_coordinator, Last_Error_Timestamp, 1);
let $ps_value_without_hyphons= `SELECT REPLACE("$ps_value", '-', '')`;
let $ps_value_in_sss_format= `select substring("$ps_value_without_hyphons", 3)`;
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be same.;
let $assert_cond= "$sss_value" = "$ps_value_in_sss_format";
source include/rpl_assert.inc;

# Verify that the error fields are preserved after STOP SLAVE.

# Extract the error related fields from SSS and PS table and compare them
# for correctness.
let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_coordinator, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_execute_status_by_coordinator, Last_Error_Message, 1);

let PS_VALUE= $ps_value;
let SSS_VALUE= $sss_value;

perl;
use strict;
my $ps_value= $ENV{'PS_VALUE'};
my $sss_value= $ENV{'SSS_VALUE'};

if ($ps_value eq $sss_value)
{
  print "Value returned by SSS and PS table for Last_Error_Message is same.\n";
}
else
{
  print "Value returned by SSS and PS table for Last_Error_Message is NOT same\n";
}
EOF

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_coordinator, Last_Error_Timestamp, 1);
let $ps_value_without_hyphons= `SELECT REPLACE("$ps_value", '-', '')`;
let $ps_value_in_sss_format= `select substring("$ps_value_without_hyphons", 3)`;
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be same.;
let $assert_cond= "$sss_value" = "$ps_value_in_sss_format";
source include/rpl_assert.inc;

STOP SLAVE;
RESET SLAVE;
--connection master
drop table t;
RESET MASTER;

--let $rpl_server_number= 1
--source include/rpl_restart_server.inc

--let $rpl_server_number= 2
--source include/rpl_restart_server.inc

--connection slave
replace_result $MASTER_MYPORT MASTER_MYPORT;
replace_column 2 ###;
eval change master to master_host='127.0.0.1',master_port=$MASTER_MYPORT, master_user='root';
start slave;

# Extract the error related fields from SSS and PS table and compare them
# for correctness.
let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Errno, 1);
let $ps_value= query_get_value(select Last_Error_Number from performance_schema.replication_execute_status_by_coordinator, Last_Error_Number, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Number should be same.;
let $assert_cond= "$sss_value" = "$ps_value";
source include/rpl_assert.inc;

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error, 1);
let $ps_value= query_get_value(select Last_Error_Message from performance_schema.replication_execute_status_by_coordinator, Last_Error_Message, 1);

let PS_VALUE= $ps_value;
let SSS_VALUE= $sss_value;

perl;
use strict;
my $ps_value= $ENV{'PS_VALUE'};
my $sss_value= $ENV{'SSS_VALUE'};

if ($ps_value eq $sss_value)
{
  print "Value returned by SSS and PS table for Last_Error_Message is same.\n";
}
else
{
  print "Value returned by SSS and PS table for Last_Error_Message is NOT same\n";
}
EOF

let $sss_value= query_get_value(SHOW SLAVE STATUS, Last_SQL_Error_Timestamp, 1);
let $ps_value= query_get_value(select Last_Error_Timestamp from performance_schema.replication_execute_status_by_coordinator, Last_Error_Timestamp, 1);
let $assert_text= Value returned by SSS and PS table for Last_Error_Timestamp should be 0000-00-00 00:00:00.;
let $assert_cond= "$ps_value" = "0000-00-00 00:00:00";
source include/rpl_assert.inc;

source include/rpl_end.inc;
