--source include/have_innodb.inc
--source include/have_debug.inc
--source include/not_valgrind.inc

####################################################################
# TC to test temp-table DML optimization changes for correctness   #
# Sceanrio covered:						   #
# 1. autocommit: operating all dml stmt with auto-commit on        #
# 2. begin-commit-rollback: sequence of dml stmt with trx that is  #
#    is committed and rollback post commit to see effect.          #
# 3. begin-rollback: sequence of dml stmt with trx rollback.       #
#    given that undo logs are generated for trx, rollback should   #
#    succeed.                                                      #
# 4. begin-savepoint-rollback-commit: dml stmt with trx involving  #
#    savepoint.                                                    #
# 5. bulk-insert with rollback + commit: this will ensure btree    #
#    node split with rollback and commit.                          #
# 6. test insert/delete/update of big-rec (blob)		   #
# 7. check error test-cases where-in insert/delete/update fails    #
####################################################################


#-------------------------------------------------------------------
#
# 1. autocommit: operating all dml stmt with auto-commit on        #
#
use test;
--disable_warnings
drop table if exists t;
--enable_warnings
create temporary table t (
	i int,
	f float,
	primary key pk_index(i),
	index sec_index(f)
	) engine = innodb;
insert into t values (10, 2.2), (20, 3.3), (30, 4.4), (40, 5.5);
#
rollback;
select * from t;
update t set i = 50 where i = 40;
update t set i = 60 where i = 30;
rollback;
select * from t;
delete from t where i = 10;
delete from t where f < 3.4;
rollback;
select * from t;
delete from t where i = 10;
delete from t;
select * from t;
drop table if exists t;

#-------------------------------------------------------------------
#
# 2. begin-commit-rollback: sequence of dml stmt with trx that is  #
#    is committed and rollback post commit to see effect.          #
#
create temporary table t (
	i int,
	f float,
	primary key pk_index(i),
	index sec_index(f)
	) engine = innodb;
begin;
insert into t values (10, 2.2), (20, 3.3), (30, 4.4), (40, 5.5);
select * from t;
commit;
select * from t;
rollback;
select * from t;
drop table if exists t;

#-------------------------------------------------------------------
#
# 3. begin-rollback: sequence of dml stmt with trx rollback.       #
#    given that undo logs are generated for trx, rollback should   #
#    succeed.                                                      #
#
create temporary table t (
	i int,
	f float,
	primary key pk_index(i),
	index sec_index(f)
	) engine = innodb;
begin;
insert into t values (10, 2.2), (20, 3.3), (30, 4.4), (40, 5.5);
select * from t;
rollback;
select * from t;
insert into t values (10, 2.2), (20, 3.3), (30, 4.4), (40, 5.5);
begin;
delete from t;
select * from t;
rollback;
select * from t;
begin;
update t set i = 50 where i = 40;
update t set i = 60 where i = 30;
select * from t;
rollback;
select * from t;
drop table if exists t;

#-------------------------------------------------------------------
#
# 4. begin-savepoint-rollback-commit: dml stmt with trx involving  #
#    savepoint.                                                    #
#
create temporary table t (
	i int,
	f float,
	primary key pk_index(i),
	index sec_index(f)
	) engine = innodb;
start transaction;
savepoint first;
insert into t values (10, 2.2), (20, 3.3), (30, 4.4), (40, 5.5);
select * from t;
rollback to first;
select * from t;
insert into t values (10, 2.2), (20, 3.3), (30, 4.4), (40, 5.5);
begin;
delete from t where i = 10;
select * from t;
savepoint first;
delete from t;
select * from t;
rollback to first;
select * from t;
commit;
select * from t;
begin;
update t set i = 50 where i = 40;
savepoint first;
update t set i = 60 where i = 30;
select * from t;
rollback to first;
select * from t;
commit;
drop table if exists t;


#-------------------------------------------------------------------
#
# 5. bulk-insert with rollback + commit: this will ensure btree    #
#    node split with rollback and commit.                          #
#
create temporary table t1
        (keyc int, c1 char(100), c2 char(100),
         primary key(keyc), index sec_index(c1)
	) engine = innodb;
create temporary table t2
        (keyc int, c1 char(100), c2 char(100),
         primary key(keyc), index sec_index(c1)
	) engine = innodb;
--source suite/innodb/include/innodb_dml_ops.inc
drop table t1;
drop table t2;
#
let $format = `select @@innodb_file_format`;
set global innodb_file_format = 'Barracuda';
create temporary table t1
        (keyc int, c1 char(100), c2 char(100),
         primary key(keyc), index sec_index(c1)
	) engine = innodb key_block_size = 4;
create temporary table t2
        (keyc int, c1 char(100), c2 char(100),
         primary key(keyc), index sec_index(c1)
	) engine = innodb key_block_size = 8;
--source suite/innodb/include/innodb_dml_ops.inc
drop table t1;
drop table t2;
eval set global innodb_file_format = $format;
#
let $file_per_table = `select @@innodb_file_per_table`;
set global innodb_file_per_table = 0;
create temporary table t1
        (keyc int, c1 char(100), c2 char(100),
         primary key(keyc), index sec_index(c1)
	) engine = innodb;
create temporary table t2
        (keyc int, c1 char(100), c2 char(100),
         primary key(keyc), index sec_index(c1)
	) engine = innodb;
--source suite/innodb/include/innodb_dml_ops.inc
drop table t1;
drop table t2;
eval set global innodb_file_per_table = $file_per_table;
#

#-------------------------------------------------------------------
#
# 6. test insert/delete/update of big-rec (blob)		   #
#
use test;
let $wait_condition=
  select variable_value < 1 from information_schema.global_status
  where variable_name = 'INNODB_PURGE_TRX_ID_AGE';
create temporary table t1
	(i int, b mediumblob,
	 primary key pk(i), index sk(b(100))
	) engine=innodb;
delimiter |;
create procedure populate_t1()
	begin
	declare i int default 1;
        while (i <= 100) do
		insert into t1 values (i, repeat(i,1000000));
    		set i = i + 1;
        end while;
end|
create procedure populate_t1_small()
	begin
	declare i int default 1;
        while (i <= 8) do
		insert into t1 values (i, repeat(i,1000000));
    		set i = i + 1;
        end while;
end|
delimiter ;|
#
begin;
select count(*) from t1;
call populate_t1();
select count(*) from t1;
delete from t1 where i < 10;
select count(*) from t1;
commit;
set global innodb_purge_stop_now=ON;
set global innodb_purge_run_now=ON;
--source include/wait_condition.inc
#
delete from t1 where i < 20;
select count(*) from t1;
#
begin;
call populate_t1_small();
select count(*) from t1;
rollback;
select count(*) from t1;
#
begin;
select count(*) from t1;
update t1 set b = repeat('a', 100) where i < 100;
select * from t1 limit 1;
select count(*) from t1;
rollback;
update t1 set b = repeat('a', 100) where i < 100;
select * from t1 limit 1;
#
truncate table t1;
select count(*) from t1;
#
drop table if exists t1;
drop procedure populate_t1;
drop procedure populate_t1_small;

#-------------------------------------------------------------------
#
# 7. check error test-cases where-in insert/delete/update fails    #
#
use test;
create temporary table t1 (i int, f float,
	primary key pk(i),
	unique index fk(f)
	) engine = innodb;
insert into t1 values (1, 1.2), (2, 2.3), (3, 3.4);
select * from t1;
--error ER_DUP_ENTRY
insert into t1 values (4, 4.5), (1, 5.6);
select * from t1;
insert into t1 values (4, 4.5), (5, 5.6);
select * from t1;
#
--error ER_DUP_ENTRY
update t1 set i = 1 where i = 4;
truncate table t1;
insert into t1 values (1, 1.2), (3, 2.3), (5, 3.4), (6, 7.4);
select * from t1;
--error ER_DUP_ENTRY
update t1 set i = i + 1;
select * from t1;
drop table t1;

#
# remove test-bed
#


