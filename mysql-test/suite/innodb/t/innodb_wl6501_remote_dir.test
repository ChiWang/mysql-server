# =====================  purpose  =======================================
# The test verifies that the internal InnoDB 'TRUNCATE TABLE' statement
# is atomic. To table with a remote data directory, recovery works fine
# from a crash during the truncation.
#

# Valgrind would complain about memory leaks when we crash on purpose.
--source include/not_valgrind.inc
# Embedded server does not support crashing
--source include/not_embedded.inc
# Avoid CrashReporter popup on Mac
--source include/not_crashrep.inc

--source include/have_innodb_16k.inc
--source include/have_debug.inc

--disable_query_log
let $MYSQL_DATA_DIR= `select @@datadir`;
let $data_directory = data directory='$MYSQL_TMP_DIR/alt_dir';
let $innodb_file_per_table_orig=`select @@innodb_file_per_table`;
let $innodb_file_format_orig=`select @@innodb_file_format`;
let $innodb_file_format_max_orig=`select @@innodb_file_format_max`;
--enable_query_log
set global innodb_file_per_table=on;
set global innodb_file_format='Barracuda';

--disable_warnings
drop table if exists t1;
--enable_warnings

--disable_query_log
set session debug="+d,crash_during_drop_second_secondary";
--enable_query_log
--echo # Verify that recovery works fine from a crash during
--echo # the drop of the second secondary to a table with
--echo # remote data directory and dynamic format.
--mkdir $MYSQL_TMP_DIR/alt_dir
--replace_result $MYSQL_TMP_DIR mysql_tmp_dir
eval create table t1(a int not null,
 b int not null,
 c int not null,
 d blob not null,
 primary key (a),
 index (b),
 index (c,d(120)))
row_format=dynamic engine=innodb $data_directory;

-- disable_query_log
-- disable_result_log
let $n_rows=100;
let $n=$n_rows;
while ($n > 0)
{
  eval insert into t1 values($n,$n,$n,repeat("a",60000));
  dec $n;
}
-- enable_result_log
-- enable_query_log
select count(*) from t1;

-- echo # Write file to make mysql-test-run.pl expect crash and restart
-- exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
-- echo # Run the crashing query
-- error 2013
truncate table t1;

-- source include/wait_until_disconnected.inc
-- enable_reconnect
-- echo # Restart the MySQL server
-- exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
-- source include/wait_until_connected_again.inc
-- disable_reconnect
select count(*) from t1;

-- disable_query_log
-- disable_result_log
let $n=$n_rows;
while ($n > 0)
{
  eval insert into t1 values($n,$n,$n,repeat("a",60000));
  dec $n;
}
-- enable_result_log
-- enable_query_log
select count(*) from t1;

-- echo # Verify that 'TRUNCATE TABLE' statement can empty a table normally.
truncate table t1;
select count(*) from t1;

-- echo # Verify that we can insert data into the truncated table normally.
-- disable_query_log
-- disable_result_log
let $n=$n_rows;
while ($n > 0)
{
  eval insert into t1 values($n,$n,$n,repeat("a",60000));
  dec $n;
}
-- enable_result_log
-- enable_query_log
select count(*) from t1;

drop table t1;

--rmdir $MYSQL_TMP_DIR/alt_dir/test
--rmdir $MYSQL_TMP_DIR/alt_dir

--disable_query_log
set session debug="-d,crash_during_drop_second_secondary";
--enable_query_log

-- disable_query_log
eval set global innodb_file_format=$innodb_file_format_orig;
eval set global innodb_file_format_max=$innodb_file_format_max_orig;
eval set global innodb_file_per_table=$innodb_file_per_table_orig;
-- enable_query_log
