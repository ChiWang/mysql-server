/*****************************************************************************

Copyright (c) 1994, 2013, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/btr0btr.ic
The B-tree

Created 6/2/1994 Heikki Tuuri
*******************************************************/

#include "mach0data.h"
#ifndef UNIV_HOTBACKUP
#include "mtr0mtr.h"
#include "mtr0log.h"
#include "page0zip.h"

#define BTR_MAX_NODE_LEVEL	50	/*!< Maximum B-tree page level
					(not really a hard limit).
					Used in debug assertions
					in btr_page_set_level and
					btr_page_get_level_low */

/**************************************************************//**
Gets a buffer page and declares its latching order level. */
UNIV_INLINE
buf_block_t*
btr_block_get_func(
/*===============*/
	ulint		space,		/*!< in: space id */
	ulint		zip_size,	/*!< in: compressed page size in bytes
					or 0 for uncompressed pages */
	ulint		page_no,	/*!< in: page number */
	ulint		mode,		/*!< in: latch mode */
	const char*	file,		/*!< in: file name */
	ulint		line,		/*!< in: line where called */
#ifdef UNIV_SYNC_DEBUG
	const dict_index_t*	index,	/*!< in: index tree, may be NULL
					if it is not an insert buffer tree */
#endif /* UNIV_SYNC_DEBUG */
	mtr_t*		mtr)		/*!< in/out: mtr */
{
	buf_block_t*	block;

	block = buf_page_get_gen(space, zip_size, page_no, mode,
				 NULL, BUF_GET, file, line, mtr);

	if (mode != RW_NO_LATCH) {

		buf_block_dbg_add_level(
			block, index != NULL && dict_index_is_ibuf(index)
			? SYNC_IBUF_TREE_NODE : SYNC_TREE_NODE);
	}

	return(block);
}

/**************************************************************//**
Sets the index id field of a page. */
UNIV_INLINE
void
btr_page_set_index_id(
/*==================*/
	page_t*		page,	/*!< in: page to be created */
	page_zip_des_t*	page_zip,/*!< in: compressed page whose uncompressed
				part will be updated, or NULL */
	index_id_t	id,	/*!< in: index id */
	mtr_t*		mtr)	/*!< in: mtr */
{
	if (page_zip) {
		mach_write_to_8(page + (PAGE_HEADER + PAGE_INDEX_ID), id);
		page_zip_write_header(page_zip,
				      page + (PAGE_HEADER + PAGE_INDEX_ID),
				      8, mtr);
	} else {
		mlog_write_ull(page + (PAGE_HEADER + PAGE_INDEX_ID), id, mtr);
	}
}
#endif /* !UNIV_HOTBACKUP */

#ifndef UNIV_HOTBACKUP
/********************************************************//**
Gets the node level field in an index page.
@return	level, leaf level == 0 */
UNIV_INLINE
ulint
btr_page_get_level_low(
/*===================*/
	const page_t*	page)	/*!< in: index page */
{
	ulint	level;

	ut_ad(page);

	level = mach_read_from_2(page + PAGE_HEADER + PAGE_LEVEL);

	ut_ad(level <= BTR_MAX_NODE_LEVEL);

	return(level);
}

/********************************************************//**
Sets the node level field in an index page. */
UNIV_INLINE
void
btr_page_set_level(
/*===============*/
	page_t*		page,	/*!< in: index page */
	page_zip_des_t*	page_zip,/*!< in: compressed page whose uncompressed
				part will be updated, or NULL */
	ulint		level,	/*!< in: level, leaf level == 0 */
	mtr_t*		mtr)	/*!< in: mini-transaction handle */
{
	ut_ad(page && mtr);
	ut_ad(level <= BTR_MAX_NODE_LEVEL);

	if (page_zip) {
		mach_write_to_2(page + (PAGE_HEADER + PAGE_LEVEL), level);
		page_zip_write_header(page_zip,
				      page + (PAGE_HEADER + PAGE_LEVEL),
				      2, mtr);
	} else {
		mlog_write_ulint(page + (PAGE_HEADER + PAGE_LEVEL), level,
				 MLOG_2BYTES, mtr);
	}
}

/********************************************************//**
Gets the next index page number.
@return	next page number */
UNIV_INLINE
ulint
btr_page_get_next(
/*==============*/
	const page_t*	page,	/*!< in: index page */
	mtr_t*		mtr __attribute__((unused)))
				/*!< in: mini-transaction handle */
{
	ut_ad(page && mtr);
	ut_ad(mtr_memo_contains_page(mtr, page, MTR_MEMO_PAGE_X_FIX)
	      || mtr_memo_contains_page(mtr, page, MTR_MEMO_PAGE_S_FIX));

	return(mach_read_from_4(page + FIL_PAGE_NEXT));
}

/********************************************************//**
Sets the next index page field. */
UNIV_INLINE
void
btr_page_set_next(
/*==============*/
	page_t*		page,	/*!< in: index page */
	page_zip_des_t*	page_zip,/*!< in: compressed page whose uncompressed
				part will be updated, or NULL */
	ulint		next,	/*!< in: next page number */
	mtr_t*		mtr)	/*!< in: mini-transaction handle */
{
	ut_ad(page && mtr);

	if (page_zip) {
		mach_write_to_4(page + FIL_PAGE_NEXT, next);
		page_zip_write_header(page_zip, page + FIL_PAGE_NEXT, 4, mtr);
	} else {
		mlog_write_ulint(page + FIL_PAGE_NEXT, next, MLOG_4BYTES, mtr);
	}
}

/********************************************************//**
Gets the previous index page number.
@return	prev page number */
UNIV_INLINE
ulint
btr_page_get_prev(
/*==============*/
	const page_t*	page,	/*!< in: index page */
	mtr_t*	mtr __attribute__((unused))) /*!< in: mini-transaction handle */
{
	ut_ad(page && mtr);

	return(mach_read_from_4(page + FIL_PAGE_PREV));
}

/********************************************************//**
Sets the previous index page field. */
UNIV_INLINE
void
btr_page_set_prev(
/*==============*/
	page_t*		page,	/*!< in: index page */
	page_zip_des_t*	page_zip,/*!< in: compressed page whose uncompressed
				part will be updated, or NULL */
	ulint		prev,	/*!< in: previous page number */
	mtr_t*		mtr)	/*!< in: mini-transaction handle */
{
	ut_ad(page && mtr);

	if (page_zip) {
		mach_write_to_4(page + FIL_PAGE_PREV, prev);
		page_zip_write_header(page_zip, page + FIL_PAGE_PREV, 4, mtr);
	} else {
		mlog_write_ulint(page + FIL_PAGE_PREV, prev, MLOG_4BYTES, mtr);
	}
}

/** Get the data size of a node pointer.
@param[in]	node_ptr	node pointer record
@param[in]	index		index B-tree
@return	child page number */
UNIV_INLINE
ulint
btr_node_ptr_get_data_size(
	const rec_t*		node_ptr,
	const dict_index_t*	index)
{
	ulint	extra_size;
	ulint	data_size;

	ut_ad(!page_is_leaf(page_align(node_ptr)));

	if (page_rec_is_comp(node_ptr)) {
		ut_ad(rec_get_node_ptr_flag(node_ptr));
		data_size = rec_get_size_comp(node_ptr, index, extra_size);
		ut_ad(extra_size >= REC_N_NEW_EXTRA_BYTES);
	} else {
		data_size = rec_get_size_old(node_ptr, extra_size);
		ut_ad(extra_size >= REC_N_OLD_EXTRA_BYTES);
	}

	ut_ad(data_size >= REC_NODE_PTR_SIZE);
	return(data_size);
}

/** Gets the child page number in a node pointer.
@param[in]	node_ptr	node pointer record
@param[in]	index		index B-tree
@return	child page number */
UNIV_INLINE
ulint
btr_node_ptr_get_child_page_no(
	const rec_t*		node_ptr,
	const dict_index_t*	index)
{
#if REC_NODE_PTR_SIZE != 4
# error REC_NODE_PTR_SIZE != 4
#endif
	ulint	page_no	= mach_read_from_4(
		+ btr_node_ptr_get_data_size(node_ptr, index)
		- REC_NODE_PTR_SIZE + node_ptr);

	if (page_no <= FSP_FIRST_INODE_PAGE_NO || page_no == FIL_NULL) {
		const page_t*	page = page_align(node_ptr);

		ib_logf(IB_LOG_LEVEL_ERROR,
			"invalid page number %u in a node pointer record"
			" page %u:%u offset %u, "
			"index " IB_ID_FMT " ('%s' of '%s')",
			(unsigned) page_no,
			(unsigned) page_get_space_id(page),
			(unsigned) page_get_page_no(page),
			(unsigned) (node_ptr - page),
			index->id, index->name, index->table_name);
		buf_page_print(page, 0, 0);
	}

	return(page_no);
}

/**************************************************************//**
Releases the latches on a leaf page and bufferunfixes it. */
UNIV_INLINE
void
btr_leaf_page_release(
/*==================*/
	buf_block_t*	block,		/*!< in: buffer block */
	ulint		latch_mode,	/*!< in: BTR_SEARCH_LEAF or
					BTR_MODIFY_LEAF */
	mtr_t*		mtr)		/*!< in: mtr */
{
	ut_ad(latch_mode == BTR_SEARCH_LEAF || latch_mode == BTR_MODIFY_LEAF);
	ut_ad(!mtr_memo_contains(mtr, block, MTR_MEMO_MODIFY));

	mtr_memo_release(mtr, block,
			 latch_mode == BTR_SEARCH_LEAF
			 ? MTR_MEMO_PAGE_S_FIX
			 : MTR_MEMO_PAGE_X_FIX);
}
#endif /* !UNIV_HOTBACKUP */
