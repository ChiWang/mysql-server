/*****************************************************************************

Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/mtr0mtr.ic
Mini-transaction buffer

Created 11/26/1995 Heikki Tuuri
*******************************************************/

/**
Pushes an object to an mtr memo stack. */
void
mtr_t::memo_push(void* object, mtr_memo_type_t type)
{
	ut_ad(object);
	ut_ad(is_active());
	ut_ad(type >= MTR_MEMO_PAGE_S_FIX);
	ut_ad(type <= MTR_MEMO_X_LOCK);
	ut_ad(m_impl->m_magic_n == MTR_MAGIC_N);

	/* If this mtr has x-fixed a clean page then we set
	the made_dirty flag. This tells us if we need to
	grab log_flush_order_mutex at mtr_commit so that we
	can insert the dirtied page to the flush list. */

	if (type == MTR_MEMO_PAGE_X_FIX && !m_impl->m_made_dirty) {
		m_impl->m_made_dirty = is_block_dirtied(
			reinterpret_cast<const buf_block_t*>(object));
	}

	mtr_memo_slot_t*	slot;

	slot = m_impl->m_memo.push<mtr_memo_slot_t*>(sizeof(*slot));

	slot->type = type;
	slot->object = object;
}

/**
Releases the (index tree) s-latch stored in an mtr memo after a
savepoint. */
void
mtr_t::release_s_latch_at_savepoint(
	ulint		savepoint,
	rw_lock_t*	lock)
{
	ut_ad(m_impl->m_magic_n == MTR_MAGIC_N);
	ut_ad(is_active());

	ut_ad(m_impl->m_memo.size() > savepoint);

	mtr_memo_slot_t* slot = m_impl->m_memo.at<mtr_memo_slot_t*>(savepoint);

	ut_ad(slot->object == lock);
	ut_ad(slot->type == MTR_MEMO_S_LOCK);

	rw_lock_s_unlock(lock);

	slot->object = NULL;
}

/**
Returns the log object of a mini-transaction buffer.
@return	log */
mtr_buf_t*
mtr_t::get_log() const
{
	ut_ad(m_impl->m_magic_n == MTR_MAGIC_N);

	return(&m_impl->m_log);
}

/**
Gets the logging mode of a mini-transaction.
@return	logging mode: MTR_LOG_NONE, ... */
mtr_log_t
mtr_t::get_log_mode() const
{
	ut_ad(m_impl->m_log_mode >= MTR_LOG_ALL);
	ut_ad(m_impl->m_log_mode <= MTR_LOG_SHORT_INSERTS);

	return(m_impl->m_log_mode);
}

/**
Changes the logging mode of a mini-transaction.
@return	old mode */
mtr_log_t
mtr_t::set_log_mode(mtr_log_t mode)
{
	ut_ad(mode >= MTR_LOG_ALL);
	ut_ad(mode <= MTR_LOG_SHORT_INSERTS);

	mtr_log_t	old_mode = m_impl->m_log_mode;

	if (mode != MTR_LOG_SHORT_INSERTS || old_mode != MTR_LOG_NONE) {
		m_impl->m_log_mode = mode;
	}

	ut_ad(old_mode >= MTR_LOG_ALL);
	ut_ad(old_mode <= MTR_LOG_SHORT_INSERTS);

	return(old_mode);
}

/**
Locks a lock in s-mode. */
void
mtr_t::s_lock(rw_lock_t* lock, const char* file, ulint line)
{
	rw_lock_s_lock_inline(lock, 0, file, line);

	memo_push(lock, MTR_MEMO_S_LOCK);
}

/**
Locks a lock in x-mode. */
void
mtr_t::x_lock(rw_lock_t* lock, const char* file, ulint line)
{
	rw_lock_x_lock_inline(lock, 0, file, line);

	memo_push(lock, MTR_MEMO_X_LOCK);
}

/**
Reads 1 - 4 bytes from a file page buffered in the buffer pool.
@return	value read */
ulint
mtr_t::read_ulint(const byte* ptr, mlog_id_t type) const
{
	ut_ad(is_active());
	ut_ad(memo_contains_page(get_memo(), ptr, MTR_MEMO_PAGE_S_FIX)
	      || memo_contains_page(get_memo(), ptr, MTR_MEMO_PAGE_X_FIX));

	return(mach_read_ulint(ptr, type));
}

